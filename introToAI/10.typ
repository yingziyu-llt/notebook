= 全局搜索
参考书：Atificial Intelligence,A Mordern Approach
== 问题的定义和问题的解
#emph[难点：把问题用一个统一的模型描述出来，用通用的搜索方法处理]
一个问题的定义包含5个部分
+ 初始状态$S_0$
+ 可选的动作$A$
+ 状态转移模型$P$
+ 目标状态$G$
+ 路径花费$"cost"$

一个问题的解就是从初始状态到目标状态的动作序列。

== 搜索
概念：
- 搜索树
- 父节点、子节点、叶子节点
- 开节点集(frontier)，就是所有还没搜子节点的节点集合
- 闭节点集(explored set)，树上除了开节点集的节点
- 搜索策略

树搜索和图搜索：树搜索对状态不判重，图搜索要判重

== 无信息搜索
=== 广搜
#emph[一旦搜到，就是最优解。]

时间复杂度和空间复杂度都很大

=== 深搜

相对于广搜，内存消耗小

使用迭代加深方法避免错失某些浅层的解。

=== 一致代价
类似于Dijstria
以从原点到当前点的距离为展开的依据，选择最小的展开。当目标将要被展开的时候，得到最优解。

== 有信息搜索
有信息搜索：运用问题相关知识，更有效地搜索。
被选择展开的节点是由估值函数$f(x)$决定的。
=== A\*

一致代价只看前面的花费，效率低；贪婪优先只看后面的花费，不一定能找到最优解。

改变策略，综合考虑前后花费，得到了A\*。

$f(x)=g(x)+h(x)$
要求：$h(x)+g(x) <= f_r(x)$，即要求h(x)是一个下界，估值函数应当是乐观的。

A\*是完备的：要求单步花费是有下界的，且分支数有界，则算法可以结束。

A\*是高效的：只展开了需要展开的节点。

效果完全看启发式函数。

使用松弛法设计启发式函数，就是松弛问题的限制，比如走地图可以飞过障碍物等等。松弛问题一定比原问题有更优的解。
